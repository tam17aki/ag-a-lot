;;; ag-a-lot.el --- manages multiple search results buffers for ag.el

;; Copyright (C) 2008-2012 Avi Rozen
;; Copyright (C) 2013 Akira Tamamori

;; Author: Avi Rozen <avi.rozen@gmail.com>
;;         Akira Tamamori <tamamori5917@gmail.com>
;; URL: https://https://github.com/tam17aki/ag-a-lot.el
;; Keywords: tools, convenience, search
;; Version: 1.0
;; Package-Requires ((ag "0.23"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
;; Boston, MA 02110-1301, USA.

;;; Commentary:

;; This package manages multiple search results buffers:
;; - the search results of `ag' are sent
;;   to separate buffers instead of overwriting the contents of a single
;;   buffer (buffers are named *ag*<N> where N is a number)
;; - several navigation functions are provided to allow the user to treat
;;   the search results buffers as a stack and/or ring, and to easily reset
;;   the state of each search buffer after navigating through the results
;;
;; Installation:
;;
;; 1. Put this file in a directory that is a member of load-path, and
;;    byte-compile it (e.g. with `M-x byte-compile-file') for better
;;    performance.
;;
;; 2. Install ag.el (https://github.com/Wilfred/ag.el).
;;
;; 3. Add the following to your ~/.emacs:
;;    (require 'ag-a-lot)
;;    (ag-a-lot-setup-keys)
;;
;; Currently, there are no customization options.
;;
;; Default Key Bindings:
;;
;; Ring navigation:
;; M-g M-]       Go to next search results buffer, restore its current search context
;; M-g M-[       Ditto, but selects previous buffer.
;;               Navigation is cyclic.
;;
;; Stack navigation:
;; M-g M--       Pop to previous search results buffer (kills top search results buffer)
;; M-g M-_       Clear the search results stack (kills all ag-a-lot buffers!)
;;
;; Other:
;; M-g M-=       Restore buffer and position where current search started
;;

;;; Code:

(require 'ag)

(defconst ag-a-lot-buffer-name-regexp "^\\*ag\\*<\\([0-9]+\\)>$"
  "Buffer name regular expression for extracting stack position.")

(defvar ag-a-lot-is-current-buffer nil
  "Default value for buffer local variable `ag-a-lot-is-current-buffer'.")

(defvar ag-a-lot-context-initial nil
  "Default value for buffer local variable `ag-a-lot-context-initial'.")

(defvar ag-a-lot-context nil
  "Default value for buffer local variable `ag-a-lot-context'.")

(defun ag-a-lot-buffer-p (&optional buffer)
  "Return non-nil if BUFFER is a ag-a-lot search result buffer.
The buffer name must match `ag-a-lot-buffer-name-regexp'.
With no argument or nil as argument, check current buffer."
  (let ((name (buffer-name buffer)))
    (if (string-match ag-a-lot-buffer-name-regexp name)
        (get-buffer name)
      nil)))

(defun ag-a-lot-current-buffer-p (&optional buffer)
  "Return non-nil if BUFFER is the current ag-a-lot search result buffer.
With no argument or nil as argument, check current buffer."
  (let ((buffer (ag-a-lot-buffer-p buffer)))
    (if buffer
        (with-current-buffer buffer
          (if ag-a-lot-is-current-buffer
              buffer
            nil))
      nil)))

(defun ag-a-lot-buffers (&optional reverse)
  "Return a sorted list of ag-a-lot search result buffers.
With REVERSE non-nil the sort order is reversed."
  (let* ((buffers nil)
         (all-buffers (buffer-list)))
    ;; filter out non ag-a-lot buffers
    (while all-buffers
      (let ((buffer (car all-buffers)))
        (if (ag-a-lot-buffer-p buffer)
            (setq buffers (append buffers (list buffer))))
        (setq all-buffers (cdr all-buffers))))
    ;; sort buffers
    (sort buffers (lambda (a b)
                    (let ((pos-a (ag-a-lot-buffer-position (buffer-name a)))
                          (pos-b (ag-a-lot-buffer-position (buffer-name b))))
                      (if reverse
                          ;; assume pos-a and pos-b are not equal
                          (< pos-b pos-a)
                        (< pos-a pos-b)))))))

(defun ag-a-lot-last-buffer ()
  "Return last ag-a-lot buffer."
  (car (last (ag-a-lot-buffers))))

(defun ag-a-lot-get-current-buffer (&optional buffers)
  "Returns the current search results buffer, from the list BUFFERS.
Returns nil if no such buffer exists.
BUFFERS can either be a list generated by `ag-a-lot-buffers' or nil,
in which case the list of buffers to consider is generated
by `ag-a-lot-buffers'."
  (let ((current nil)
        (buffers (or buffers (ag-a-lot-buffers))))
    (while buffers
      (if (ag-a-lot-current-buffer-p (car buffers))
          (setq current (car buffers)
                buffers nil)
        (setq buffers (cdr buffers))))
    current))

(defun ag-a-lot-set-current-buffer (&optional current-buffer)
  "Set CURRENT-BUFFER as current search results buffer.
If CURRENT-BUFFER is not specified or is nil, then use current buffer."
  (let ((buffers (ag-a-lot-buffers))
        (current-buffer (get-buffer (buffer-name current-buffer))))
    ;; reset is-current flag in all buffers
    (while buffers
      (let ((buffer (car buffers)))
        (with-current-buffer buffer
          (set (make-local-variable 'ag-a-lot-is-current-buffer) nil)))
      (setq buffers (cdr buffers)))
    ;; set is-current flag in current-buffer
    (with-current-buffer current-buffer
      (set (make-local-variable 'ag-a-lot-is-current-buffer) t))))

(defun ag-a-lot-next-buffer (&optional reverse)
  "Return next ag-a-lot buffer.
When REVERSE is non-nil, return previous buffer.
If current buffer is last then return first buffer.
Returns nil if there is no ag-a-lot buffer to select."
  (let* ((buffers (ag-a-lot-buffers reverse))
         (current (ag-a-lot-get-current-buffer buffers))
         (head (car buffers))
         (next (car (cdr (member current buffers)))))
    (and current (or next head))))

(defun ag-a-lot-prev-buffer ()
  "Return previous ag-a-lot buffer.
Actually calls `ag-a-lot-next-buffer'."
  (ag-a-lot-next-buffer t))

(defun ag-a-lot-buffer-position (name)
  "Return position of ag-a-lot buffer named NAME.
Return -1 if NAME is does not match `ag-a-lot-buffer-name-regexp'."
  (if (and (stringp name)
           (string-match ag-a-lot-buffer-name-regexp name))
      (string-to-number (match-string 1 name))
    -1))

(defun ag-a-lot-buffer-name (position)
  "Return name of ag-a-lot buffer at POSITION."
  (concat "*ag*<" (number-to-string position) ">"))

(defun ag-a-lot-buffer-name-function (name)
  "Set current ag search results buffer name."
  (when (string-match "^ag$" name)
    (ag-a-lot-buffer-name (1+ (ag-a-lot-buffer-position
                               (buffer-name (ag-a-lot-last-buffer)))))))

(defun ag-a-lot-kill-buffer-hook ()
  "Select previous buffer as current, in case current buffer is being killed."
  (if (and (ag-a-lot-buffer-p) ag-a-lot-is-current-buffer)
      (ag-a-lot-set-current-buffer (ag-a-lot-prev-buffer))))

(defun ag-a-lot-ag-setup-hook ()
  "Setup buffer local storage of original buffer context."
  ;; ag-a-lot-context-initial is supposed to be set already
  ;; by advised ag functions
  (make-local-variable 'ag-a-lot-context-initial)
  (set (make-local-variable 'ag-a-lot-context) ag-a-lot-context-initial)
  (ag-a-lot-set-current-buffer))

(defun ag-a-lot-next-error-hook ()
  "Next error hook function used to maintain the search buffer context."
  (let ((position (ag-a-lot-buffer-position
                   (buffer-name next-error-last-buffer))))
    (when (>= position 0)
      (let ((context (point-marker)))
        (with-current-buffer next-error-last-buffer
          (set (make-local-variable 'ag-a-lot-context) context)
          (ag-a-lot-set-current-buffer))))))

;; register hooks
(add-hook 'next-error-hook 'ag-a-lot-next-error-hook)
(add-hook 'ag-mode-hook 'ag-a-lot-ag-setup-hook)
(add-hook 'kill-buffer-hook 'ag-a-lot-kill-buffer-hook)

(defun ag-a-lot-restore-context (ag-buffer &optional initial)
  "Restore AG-BUFFER context.
If INITIAL is non nil then use initial context."
  (let* ((context (and ag-buffer
                       (with-current-buffer ag-buffer
                         (if initial
                             ag-a-lot-context-initial
                           ag-a-lot-context)))))
    (when ag-buffer
      (pop-to-buffer ag-buffer)
      (ag-a-lot-set-current-buffer ag-buffer))
    (when context
      (when initial
        (goto-char (point-min))
        (setq compilation-current-error nil))
      (let* ((buffer (marker-buffer context))
             (pos (marker-position context)))
        (when buffer
          (pop-to-buffer buffer)
          (goto-char pos))))))

;;;###autoload
(defun ag-a-lot-restart-context (&optional ag-buffer)
  "Restart buffer and position for the current search results buffer AG-BUFFER.
If AG-BUFFER is nil then restart context of current search results buffer."
  (interactive)
  (let ((ag-buffer (or (ag-a-lot-buffer-p ag-buffer)
                         (ag-a-lot-get-current-buffer))))
    (ag-a-lot-restore-context ag-buffer t)))

;;;###autoload
(defun ag-a-lot-goto-next ()
  "Goto next search results buffer."
  (interactive)
  (ag-a-lot-restore-context (ag-a-lot-next-buffer)))

;;;###autoload
(defun ag-a-lot-goto-prev ()
  "Goto previous search results buffer."
  (interactive)
  (ag-a-lot-restore-context (ag-a-lot-prev-buffer)))

;;;###autoload
(defun ag-a-lot-pop-stack ()
  "Switch to previous search results buffer, and kill current buffer."
  (interactive)
  (let ((buffer (ag-a-lot-last-buffer)))
    (when buffer
      (ag-a-lot-set-current-buffer buffer)
      (ag-a-lot-goto-prev)
      (kill-buffer buffer))))

;;;###autoload
(defun ag-a-lot-clear-stack ()
  "Kill all ag search results buffers."
  (interactive)
  (mapcar 'kill-buffer (ag-a-lot-buffers)))

;;;###autoload
(defun ag-a-lot-setup-keys ()
  "Define some key bindings for navigating multiple
ag search results buffers."
  (define-key esc-map (kbd "g M-]") 'ag-a-lot-goto-next)
  (define-key esc-map (kbd "g M-[") 'ag-a-lot-goto-prev)
  (define-key esc-map (kbd "g M--") 'ag-a-lot-pop-stack)
  (define-key esc-map (kbd "g M-_") 'ag-a-lot-clear-stack)
  (define-key esc-map (kbd "g M-=") 'ag-a-lot-restart-context))

(defmacro ag-a-lot-advise (func)
  "Advise a ag-like function FUNC with an around-type advice,
so as to enable multiple search results buffers."
  (let ((name (make-symbol (concat "ag-a-lot-" (symbol-name func)))))
    `(defadvice ,func (around ,name activate)
       "Use multiple search-results buffers."
       (let ((ag-a-lot-context-initial (point-marker))
             (compilation-buffer-name-function 'ag-a-lot-buffer-name-function))
         ad-do-it
         ad-return-value))))

(ag-a-lot-advise ag)

(provide 'ag-a-lot)

;;; ag-a-lot.el ends here
